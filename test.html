<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .border {
        border: 1px solid black;
      }
      .wh100 {
        width: 100px;
        height: 100px;
      }
      .wrapper {
        display: flex;
        justify-content: space-between;
      }
      .content {
        width: 100%;
      }
      .left {
        flex: 1;
      }
      .right {
        min-width: 300px;
        height: 100px;
      }
    </style>
  </head>
  <body>
    <script>
      //
      // alert(typeof NaN)                                                         //Number
      // alert(typeof undefined)                                                                      // undefined
      // alert(typeof null)                                                                // Object

      // for (var i = 0; i < 3; i++) {
      //   setTimeout(function () {
      //     console.log(i)
      //   }, 1000 * 3)
      // }

      // var x
      // for (var i = 0, j = 0; i < 6, j < 10; i++, j++) {
      //   x = i + j
      //   console.log('log - i , j', i, j)
      // }
      // console.log(x) //18

      // var bar = 1
      // function test() {
      //   console.log(bar)                                                             // undefined
      //   var bar = 2
      //   console.log(bar)                                                                // 2
      // }
      // test()

      // var foo = function () {
      //   console.log(1)
      // }
      // function foo() {
      //   console.log(2)
      // }
      // foo()                                                                                 // 1

      // function c() {
      //   var b = 1
      //   function a() {
      //     console.log(b)
      //     var b = 2
      //     console.log(b)
      //   }
      //   a()
      //   console.log(b)
      // }
      // c()                                                                               // undefined 2 1
      // ----------------------------------------------------------2
      // function Foo() {
      //   getName = function () {
      //     console.log(1)
      //   }
      //   console.log(this) // Foo
      //   return this
      // }
      // Foo.getName = function () {
      //   console.log(2)
      // }
      // Foo.prototype.getName = function () {
      //   console.log(3)
      // }
      // var getName = function () {
      //   console.log(4)
      // }
      // Foo.getName()                                                                               // 2
      // getName()                                                                                     // 4
      // Foo.getName()                                                                                     // 2
      // getName()                                                                                    // 4
      // new Foo().getName()                                                                           // 3

      //
      // function a() {
      //   console.log('fun')
      // }
      // var a = function () {
      //   console.log('var')
      // }
      // a()
      // 请用三种方式写出4平分一个div的布局方式

      // es5和es6封装一个数组去重方法

      // 封装一个深拷贝的方法

      // 身份证正则

      // for (var i = 0; i < 5; i++) {
      //   setTimeout(() => {
      //     console.log(i)
      //   }, 1000)
      // }

      // var obj1 = {
      //   a: 'hellow',
      // }
      // var obj2 = obj1
      // obj2.a = 'world'
      // console.log(obj1)                                                                                     // world
      // ;(function () {
      //   console.log(a)                                                                                     // undefined
      //   var a = 1
      // })()

      // function Hero() {
      //   this.name = 'nihao'
      //   this.sayMe = function () {
      //     console.log('this is nihao')
      //   }
      // }
      // Hero.prototype.name = 'hellow'
      // Hero.prototype.sayMe = function () {
      //   console.log('this is helllow')
      // }
      // var hero = new Hero()
      // console.log(hero.name)                                                                                     //nihao
      // console.log(hero.sayMe)                                                                                     //function () {console.log('this is nihao')}
      // ------------------------------------------------------------------2
      // function Foo() {
      //   var i = 0
      //   return function () {
      //     console.log(i++)
      //   }
      // }
      // var f1 = Foo()
      // var f2 = Foo()
      // f1()
      // f1()
      // f2()

      // var a1 = [3, 1, 22]
      // var a2 = [4, 23]
      // a1.concat(a2)
      // a1.sort()
      // console.log([12, 3, 23].sort())                                                                                     //[12, 23, 3]
      // console.log(a1.join(';'))                                                                                     // 1;22;3
      // console.log(a1)

      // function deefClone(obj) {
      //   if (typeof obj != 'object') return
      //   const tmp = obj.constructor === Object ? {} : []
      //   for (key in obj) {
      //     if (obj.hasOwnProperty(key)) {
      //       tmp[key] = obj[key].constructor === Object ? deefClone(obj[key]) : obj[key]
      //     }
      //   }
      //   return tmp
      // }
      // function deefClone(obj) {
      //   if (typeof obj != 'object') return
      //   let temp = obj instanceof Object ? {} : []
      //   console.log('log - deefClone - obj.instanceof', obj.instanceof)
      //   for (key in obj) {
      //     if (obj.hasOwnProperty(key)) {
      //       temp[key] = obj[key] instanceof Object ? deefClone(obj[key]) : obj[key]
      //     }
      //   }
      //   return temp
      // }
      // console.log(deefClone({ a: { c: { wer: 'sadfsdf' } } }))
      // const a = {
      //   a: 'asdf',
      //   b: {
      //     c: 'sdaf',
      //     d: 'dsaf',
      //     e: {
      //       tes: 'sdaf',
      //     },
      //   },
      //   c: {
      //     a: 'fsad',
      //   },
      //   d: 'dsaf',
      // }

      // new 操作干了什么
      // 1、创建一个空对象
      // 2、把这个空对象的__proto__指向构造函数的prototype
      // 3、把构造函数的this指向这个空对象
      // 4、新对象属性赋值
      // 5、返回this
      // ----------------------------------------------------------3

      // console.log(typeof fn)                                                   // function 注意fn是提前
      // function fn() {}
      // var fn = function fn() {}
      // --------------------------------------------------------------2
      // function fun(n, o) {
      //   console.log(o)
      //   return {
      //     fun(m) {
      //       return fun(m, n)
      //     },
      //   }
      // }
      // var a = fun(0)
      // a.fun(1)
      // a.fun(2)
      // a.fun(3)
      // var b = fun(0).fun(1).fun(2).fun(3)
      // var c = fun(0).fun(1)
      // c.fun(2)
      // c.fun(3)

      // function obj() {
      //   var temp = new Object()
      //   temp.name = ''
      //   temp.getName = function () {
      //     return this.name
      //   }
      //   temp.setName = function (name) {
      //     this.name = name
      //   }
      //   return temp
      // }

      // var name = 'World'
      // ;(function () {
      //   if (typeof name === 'undefined') {
      //     var name = 'Jack'
      //     console.log('Goodbye' + name)
      //   } else {
      //     console.log('Hello' + name)
      //   }
      // })()
      // let a = 'abasadaaaaaflsdfsadfasfkasdfsadfsaskdjf'
      // let strary = a.split('')
      // let temp = {}
      // strary.forEach(item => {
      //   if (temp.hasOwnProperty(item)) {
      //     temp[item] += 1
      //   } else {
      //     temp[item] = 0
      //   }
      // })
      // let maxKey = Object.keys(temp)[0]
      // for (key in temp) {
      //   if (temp[key] > temp[maxKey]) {
      //     maxKey = key
      //   }
      // }
      // console.log(maxKey, temp[maxKey])
      // console.log(temp)
      // ------------------------------------------重点
      // var a = {}
      // var b = {
      //   key: 'a',
      // }
      // var c = {
      //   key: 'c',
      // }
      // a[b] = '123'
      // a[c] = '456'
      // for (key in a) {
      //   console.log(key)
      // }
      // console.log(a[b])

      // function Sjk() {
      //   getVal = function () {
      //     console.log(1)
      //   }
      // }
      // Sjk.getVal = function () {
      //   console.log(2)
      // }
      // Sjk.prototype.getVal = function () {
      //   console.log(3)
      //   var a = 'd'
      // }
      // var getVal = function () {
      //   console.log(4)
      // }
      // function getVal() {
      //   console.log(5)
      // }
      // Sjk.getVal()                                                                                     // 2
      // getVal()                                                                                     //4
      // Sjk.getVal()                                                                                     //2
      // getVal()                                                                                     // 4
      // var a = new Sjk().getVal() //3
      // console.log(new Sjk())
      // console.log(a)

      // console.log(true + 1)
      // console.log('name' + true)
      // console.log(undefined + 1)
      // console.log(typeof null)
      // var x = 10
      // y = '20'
      // console.log(x + y)
      // console.log(x - y)

      // 扁平化处理
      // let ary = [1, 322, 3, [13, 31, [12, 321, 312, 3], 13, 13], [1234321, 42314, 234]]
      // function flatten(ary) {
      //   return ary.reduce(function (pre, cur) {
      //     return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)
      //   }, [])
      // }
      // function test(ary) {
      //   return ary.reduce((pre, cur) => pre.concat(cur.constructor === Array ? test(cur) : cur), [])
      // }

      // function test(ary) {
      //   let tmp = ary.reduce((pre, cur) => {
      //     pre = pre.concat(Array.isArray(cur) ? test(cur) : cur)
      //     return pre
      //   }, [])
      //   return tmp
      // }
      // console.log(test(ary))
      // console.log(flatten(ary)) //  [1, 2, 3, 4，5]
      // console.log([1, 2].concat([12, 312, 312, 3123])) //[1, 2, 12, 312, 312, 3123]
      // console.log([1, 2].concat(1)) //[1, 2, 1]

      // var arr = '0123456'
      // arr2 = arr.substring(2, 5)
      // console.log(arr2)

      // function say() {
      //   var num = 666
      //   function sayAlert() {
      //     console.log(num)
      //   }
      //   num++
      //   return sayAlert
      // }
      // var demo = say()

      /* 会改变原数组
      pop 删除最后一个
      shift 删除第一个
      push 添加到最后一个 返回元素的长度
      unshift添加到第一个
      splice(a,b,...c) a 要删除元素的位置，b要删除元素的个数，c要插入的元素 删除元素与添加元素
      sort 数字排序没有添加参数的情况下只会比较第一个元素
      reverse 反转
      */

      /* 不会改变原数组
      slice(a,b)截取数组返回一个新的数组 a开始的位置，b结束的位置 包括前面不包括后面
      concat()  连接数组
      join('adf') 要拼接的数组
      find() 和filter一样的判断，但是filter返回的是数组，而find返回的是元素
      map() 判断返回成功的元素数组
      reduce
      filter
      findIndex
      indexOf
      lastIndexOf
      includes 返回boolean
      foreach
      toString
      some 和filter一样但是只要有一个成功了，就直接return返回了boolean
     
       */
      // demo()
      // 删除最后一个
      // pop
      // 删除第一个
      // shift
      // 添加最后一个
      // push
      // 添加第一个
      // unshift
      // 循环判断并返回真确的元素
      // map
      // filter
      // reduce
      // foreach
      // slice
      // splice

      // 查找
      // find(()=>) //返回元素
      // findIndex // 返回索引
      // includes // 返回Boolean

      // toString 在返回
      // join
      // concat

      // lastIndexOf
      // indexOf

      // 去重
      // let ary = ['a', 'b', 'c', 'f', 'e', 'a', 'a', 'b', 'c', 'a']
      // console.log(Array.from(new Set(ary)))
      // -------------------------------------------------------------
      // const demo = (first, ...num) => [first, num]

      // console.log(demo(1, 2, 3, 4, 5))                                                                                     // [1,[2,3,4,5]]
      // ---------------------------------------------------------------------
      // function demo() {
      //   let n = 2
      //   if (true) {
      //     let n = 1
      //   }
      //   console.log(n)
      // }
      // demo()includes
      //

      /*
                               pop
                               shift
                               slice
                               splice

                               unshift
                               push

                               reduce
                               map
                               filter
                               foreach

                               indexOf
                               lastIndexof
                               includes
                               includes

                               toString
                               concat
                               join

                               sort
                               reverse


                               字符串方法
                               split
                               charAt() 方法可以返回指定位置的字符。
                               const str = 'hello';
                               str.charAt(1)  // 输出结果：e
                               indexOf
                               lastIndexOf
                               startsWith()：该方法用于检测字符串是否以指定的子字符串开始。如果是以指定的子字符串开头返回 true，否则 false。其语法和上面的includes()方法一样
                        let str = 'Hello world!';

                        str.startsWith('Hello') // 输出结果：true
                        str.startsWith('Helle') // 输出结果：false
                        str.startsWith('wo', 6) // 输出结果：true
                                startsWith
                               endsWith()：该方法用来判断当前字符串是否是以指定的子字符串结尾。如果传入的子字符串在搜索字符串的末尾则返回 true，否则将返回 false。其语法如下：
                        concat() 方法用于连接两个或多个字符串。该方法不会改变原有字符串，会返回连接两个或多个字符串的新字符串。其语法如下
                        substr()、substring()和 slice() 方法都可以用来截取字符串。
                        replace 替换


                        删除-会改变原数组
                        pop 删除第最后一个元素返回数组长度
                        unshift 删除第一个元素
                        splice(a,b,c) a：删除的元素的位置，b：从a位置往后删删除元素的个数，c：从a位置添加的元素可以是多个
                        删除不会改变原数组
                        slice(a,b) 顾前不顾后

                        push 在末尾添加
                        shift 在开头添加

                        循环
                        filter 
                        foreach
                        map
                        reduce

                        find 判断相同返回数组的元素---------------------------1
                        findIndex
                        indexOf 第一个索引
                        lastIndexOf 最后一个
                        some 如果有一个元素满足那么就返回true不继续执行----------------------1
                        sort 会改变原数组
                        reverse 反转会改变原数组----------------------1
                        join 
                        concat 连接不会保存原数组----------------------1
                        includes 判断是否存在----------------------1































                        pop删除最后一个 并返回删除的元素，会改变本身
                        shift删除第一个，并返回删除的元素，会改变本身
                        push,unshift
                        循环
                        map(itme=>item)返回
                        includes判断是否存在
                        find(item=>iitem)返回的是元素不是数组
                        filter(item=>item)返回的数组
                        findIndex返回索引
                        concat(连接数组)
                        indexOf查找返回第一个查到到的索引
                        reduce
                        reverse反转
                        lastIndexOf
                        slice截取，包头不包尾不会改变本身
                        splice参数1在哪里开始删除，参数2删除几个，参数3需要添加的元素 会改变本身
                        sort
                        some 如果有一个元素满足那么就返回true



                                          */

      // 删除
      // pop
      // shift
      // slice
      // splice
      // 添加
      // push
      // unshift
      // 高级循环函数
      // map(()=>)
      // filter(()=>)
      // reduce(()=>)
      // foreach(()=>)

      // toString
      // 连接
      // concat
      // join
      // 查找
      // lastIndexOf
      // 返回第一次出现的索引
      // indexOf
      //是否包含某个值 返回ture、false
      // includes
      // 查找满足条件的第一个元素和filter函数一样
      // find(()=>)
      // 返回查找满足条件第一个元素的位置
      // findIndex(()=>)
      // 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测
      // some(()=>)

      // let ary = [1, 2, 3, 4, 5, 6, 7, 8, 0]
      // console.log(ary.map(item => ++item))
      // 删除最后一个 并且改变原数组
      // ary.pop()
      // 在第一个中添加，会改变原数组
      // ary.unshift(0)
      // ary.shift()
      // ary.slice(13)
      // 截取生成一个新的数组
      // console.log('log - ary.slice(1,3)', ary.slice(1, 3))
      // 会改变原来的数组
      // ary.splice(1, 3, 9, 9, 9)
      // console.log('log - ary.splice(1, 3, 9, 9, 9)', ary.splice(1, 3, 9, 9, 9))
      // 翻转
      // ary.reverse()
      // console.log(ary)
      // 实现集成的方法

      // 继承ES5
      // function superType(name) {}
      // function subType(name, age) {
      //   superType.call(this, name)
      // }
      // ES6
      // class superType {
      //   constructor(name, age) {
      //     this.name = name
      //     this.age = age
      //   }
      // }
      // class subtype extends superType {
      //   constructo() {
      //     super()
      //   }
      // }
      // let ary = [1, 23, 123, 124, 125, 345, 26, 5, 7647, 325, 3, 5]
      // for (let i = 0; i < ary.length; i++) {
      //   let max = i
      //   for (let j = i + 1; j < ary.length; j++) {
      //     max = ary[max] < ary[j] ? j : max
      //   }
      //   let tmp = ary[max]
      //   ary[max] = ary[i]
      //   ary[i] = tmp
      // }
      // console.log()
      // let ary = {
      //   a: '1',
      // }
      // let ary = '1'
      // console.log(ary)
      // switch (ary.a) {
      //   case '1':
      //     console.log(ary)
      //     break

      //   default:
      //     break
      // }
      // 填写"TO DO"处的内容让下面代码支持 a.name = "name1"; b.name = "name2";
      // function Obj(name) {
      //   if (name) {
      //     return { name }
      //   }
      //   console.log('this', this.prototype, Obj.prototype)
      // }
      // Obj.prototype.name = 'name2'
      // var a = Obj('name1')
      // var b = new Obj()
      // console.log(Obj, a, b)
      // console.log(a.name, b.name)
      //
      // const obj = {
      //   name: 'obj',
      //   b: 'tes',
      // }
      // function objfun() {
      //   this.name = 'objfun'
      // }
      // objfun.prototype.pname = 'panme'
      // console.log(Object.create(objfun).pname) //undefined

      // console.log(5 ** 2)

      // Object.create = function (fun) {
      //   var newF = function () {}
      //   newF.prototype = fun
      //   return new F()
      // }

      // function Fun() {}
      // const fun = new Fun()

      // console.log('gb:' + i)
      // var i = 1
      // foo(1)
      // function foo(i) {
      //   if (i == 4) {
      //     return
      //   }
      //   console.log('fb:' + i)
      //   foo(i + 1)
      //   console.log('fe:' + i)
      // }
      // console.log('ge:' + i)
      // var name = 'window'
      // var person1 = {
      //   name: 'person1',
      //   foo1: function () {
      //     console.log(this.name)
      //   },
      //   foo2: () => console.log(this.name),
      //   foo3: function () {
      //     return function () {
      //       console.log(this.name)
      //     }
      //   },
      //   foo4: function () {
      //     return () => {
      //       console.log(this.name)
      //     }
      //   },
      // }
      // var person2 = { name: 'person2' }

      // person1.foo1() // person1
      // person1.foo1.call(person2) // person2

      // person1.foo2() // window
      // person1.foo2.call(person2) // window

      // person1.foo3()() // window
      // person1.foo3.call(person2)() // window
      // person1.foo3().call(person2) // person2

      // person1.foo4()() // window
      // person1.foo4.call(person2)() // window
      // person1.foo4().call(person2) // window
    </script>
    <div class="wrapper">
      <div class="content wh100 border"></div>
      <div class="content wh100 border"></div>
      <div class="content wh100 border"></div>
      <div class="content wh100 border"></div>
    </div>
  </body>
</html>
